from flask_restful import Resource
from flask_jwt_extended import jwt_required
from db.db import DB
from decorator.verify_admin_access import verify_admin_access
from decorator.catch_exception import catch_exception
from decorator.log_request import log_request
from urllib import request
import json
from datetime import datetime
import re
import copy


class UpdateMoovijobJobOffers(Resource):

    def __init__(self, db: DB):
        self.db = db

    @log_request
    @catch_exception
    @jwt_required
    @verify_admin_access
    def post(self):

        base_url = "https://www.moovijob.com/api/job-offers/search?job_categories[]=informatique-consulting" \
                   "&job_categories[]=informatique-dev&job_categories[]=informatique-infra-reseau&q=security"

        response = request.urlopen(base_url)
        data = json.loads(response.read())

        nb_pages = data["last_page"] if "last_page" in data and type(data["last_page"]) == int else None
        current_page = 1
        nb_reviewed, nb_created, nb_modified = 0, 0, 0

        if nb_pages is None:
            return [], "500 No article has been treated"

        while current_page <= nb_pages:

            external_references = [str(a["id"]) for a in data["data"]]
            db_articles = self.db.get(self.db.tables["Article"], {"external_reference": external_references})

            for source_article in data["data"]:
                db_article = [a for a in db_articles if source_article["id"] == a.external_reference]
                db_article = db_article[0] if len(db_article) > 0 else self.db.tables["Article"]()

                nb_reviewed += 1
                nb_created += 1 if db_article.id is None else 0

                db_article, m1 = self._manage_article(db_article, source_article)
                db_article_version, m2 = self._manage_article_version(db_article)
                db_article_version_box, m3 = self._manage_article_version_box(db_article_version, source_article)

                nb_modified += 1 if (db_article.id is not None and (m1 or m2 or m3)) else 0

            # Prepare for next page

            current_page += 1

            if current_page <= nb_pages:
                response = request.urlopen(f"{base_url}&page={current_page}")
                data = json.loads(response.read())

        return "", f"200 Success: {nb_reviewed} treated, {nb_created} created, {nb_modified} modified"

    def _manage_article(self, a, source):

        copied_a = copy.deepcopy(a)

        today = datetime.today().strftime("%Y-%m-%d")
        title = self._get_preferred_lang_info(source['title'])
        handle = f"{source['id']}-{re.sub(r'[^a-z1-9-]', '', title.lower().replace(' ', '-'))[:80]}"

        # Insert data into Article object

        a.external_reference = source["id"] if a.external_reference is None else a.external_reference
        a.title = title if a.title is None else a.title
        a.handle = handle if a.handle is None else a.handle
        a.type = "JOB OFFER" if a.type is None else a.type
        a.publication_date = today if a.publication_date is None else a.publication_date
        a.status = "PUBLIC" if a.status is None else a.status
        a.media = "CYBERLUX" if a.media is None else a.media
        a.link = self._get_preferred_lang_info(source["urls"]) if a.link is None else a.link

        # Save modifs in DB

        article = self.db.merge(a, self.db.tables["Article"])
        is_modified = not self.db.are_objects_equal(a, copied_a, self.db.tables["Article"])

        return article, is_modified

    def _manage_article_version(self, a):

        versions = self.db.get(self.db.tables["ArticleVersion"], {"article_id": a.id, "is_main": True})

        if len(versions) == 0:
            article_version = self.db.tables["ArticleVersion"]()
            article_version.article_id = a.id
            article_version.name = "Generated by cron/update_moovijob_job_offers"
            article_version.is_main = True
            return self.db.merge(article_version, self.db.tables["ArticleVersion"]), True
        else:
            return versions[0], False

    def _manage_article_version_box(self, v, source):

        boxes = self.db.get(self.db.tables["ArticleBox"], {"article_version_id": v.id})

        if len(boxes) == 0:
            article_box = self.db.tables["ArticleBox"]()
            article_box.article_version_id = v.id
            article_box.position = 1
            article_box.type = "PARAGRAPH"
            article_box.content = self._get_preferred_lang_info(source["body"])
            return self.db.merge(article_box, self.db.tables["ArticleBox"]), True
        if len(boxes) == 1 and boxes[0].type == "PARAGRAPH":
            if boxes[0].content != self._get_preferred_lang_info(source["body"]):
                boxes[0].content = self._get_preferred_lang_info(source["body"])
                return self.db.merge(boxes[0], self.db.tables["ArticleBox"]), True
            else:
                return boxes[0].content, False
        else:
            return None, False

    @staticmethod
    def _get_preferred_lang_info(lang_dict):
        if "en" in lang_dict and lang_dict["en"] is not None:
            return lang_dict["en"]
        elif "fr" in lang_dict and lang_dict["fr"] is not None:
            return lang_dict["fr"]
        elif "de" in lang_dict and lang_dict["de"] is not None:
            return lang_dict["de"]
        elif len(lang_dict.keys()) > 0:
            return lang_dict[lang_dict.keys()[0]]
        else:
            return None
